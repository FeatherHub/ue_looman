camera position
camera collision volume
camera direction

character position 
character collision volume
character direction

relationship between Char and Cam
  Cam's position, direction
    offset from Char's position
    derived via simple addition

input 
  ws -> change Char's position
        -> change Cam's position
  ad -> change Char's direction
        -> change Cam's direction

---

sockets in character
  character's {left hand, right hand, left foot, right foot, body, ...}

relationship between Proj and Sock
  Proj's position, direction
    eqauls to Sock's position
    derived via simple reference

---

vector
  Look
    target position
    world origin
    rotator matrix
    world origin

---

event & time
  1 after (delay)
  2 duration (continues for)

  created when (event)
  destroyed when (event)

  created at (time)
  destryed after (time)

---

game-driven materials
  dynamic
    attach, turn on/off

feed descriptions 
  and engine figures out the rest
    consider interactions of
      light, material, camera,...

---

void ASProjectile::OnActorOverlap
(
  UPrimitiveComponent* OverlappedComponent,
  AActor* OtherActor,
  UPrimitiveComponent* OtherComp,
  int32 OtherBodyIndex,
  bool bFromSweep,
  const FHitResult& SweepResult,
) 

// early return
// more lines, less nests
// relevant contexts visually far
{
  if(!OtherActor) 
  {
    return;
  }

  if(OtherActor == GetInstigator()) 
  {
    return;
  }

  USAttributeComp* AttributeComp = Cast<USAttributeComp>(OtherActor->GetCompByClass(USAttributeComp::StaticClass()));
  if(!AttributeComp) 
  {
    return;
  }

  AttributeComp->ApplyHealthChange(-20.0f);
  Destroy();
}

// core logic nested within conditional block
// less lines, more nests
// relevant conditons visually close
{
  if(!OtherActor && OtherActor != GetInstig()) 
  {
    USAttributeComp* AttributeComp = Cast<USAttributeComp>(OtherActor->GetCompByClass(USAttributeComp::StaticClass()));

    if(AttrComp) {
      AttributeComp->ApplyHealthChange(-20.0f);
      Destroy();
    }
  }

}

---

// hope
USAttrComp* AttrComp = OtherActor->GetCompByClass<USAttrComp>();

// reality
USAttrComp* AttrComp = Cast<USAttrComp>(OtherActor->GetCompByClass(USAttrComp::StaticClass()));
  Cast<> marks an explicit boundary 
  crossing from UE Reflection System to C++ static Typing

// constraints 
  templates are compile time only
  
  UE wants to support 
    Reflection Systen (Runtime Type Information)
    UClass metadata generated by UHT(Unreal Header Tool)
      a kind of type token
    features
      search components
      support BP calls
      garbage collector
      serialization

---

ASTargetDummy::ASTargetDummy() 
{
  AttrComp = CreateDefaultSubobject<AttrComp>("AttrComp");

  AttrComp->OnHealthChanged.AddDynamic(this, &ASTargetDummy::OnHealthChanged);
}

MeshComp->SetScalarParameterValueOnMaterials("TimeToHit", GetWorld()->TimeSeconds);
  string-based coupling...
